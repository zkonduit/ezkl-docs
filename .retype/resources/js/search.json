[[{"l":"The EZKL System","p":["EZKL is a developer-friendly system for verifiable AI and analytics.","Analytics can be descriptive (aggregation, visualization), diagnostic (mining, statistical, querying), predictive (machine learning, time series), and prescriptive (optimization, simulation, decision). Verifiability is the ability to confirm the use of designated mathematical steps, even if you are not the executing machine.","This is useful in three core scenarios:","Running a public model on private data. For example, a research paper includes a model for detecting indicators for a specific disease. Since the model must've been trained on sensitive patient data, the author can use ezkl to prove that the benchmarks are true for the committed model and private data, without a reviewer needing to access that data.","Running a private model on public data. For example, a hedge fund leverages a model for identifying and trading on financial opportunities. Since the model is proprietary, a limited partner or investor may provide benchmarking data to the fund, and the fund can use ezkl to prove that their model is as accurate or performant as reported.","Running a public model on public data. For example, there is a computationally limited machine like a blockchain. You are a portfolio manager and want to execute rebalancing behalf of your client according to market data. While your rebalancing model may be public and the market data is public, this is too computationally expensive to calculate the adjusted values on-chain. The PM can use ezkl to apply the rebalancing model off-chain, then prove to the machine that they used this particular model and upon confirmation trigger execution on-chain. This scenario clearly affords automation in addition to verifiability","See that in all scenarios, the actor with ownership over model execution can prove that they are acting in good faith. Their actions are verifiable to a recipient of the results."]},{"l":"How This Works","p":["The underlying technology enabling this verifiability is known as zero knowledge cryptography. The proofs generated are called zero knowledge proofs (ZKPs), which enable one party (the prover) to prove to another (the verifier) that a statement is true without revealing any extra information.","Traditionally, creating ZKPs requires manually designing circuits using domain-specific languages like Circom or CirC. This process is particularly challenging for complex AI/ML models with thousands of gates.","ezkl automates ZKP generation for these complex computations as following:","Input: User provides a model (e.g., neural network) in ONNX format.","Circuit Generation: ezkl automatically converts the model into a ZKP-compatible circuit.","Proof Creation: ezkl generates a proof of correct model execution.","Verification: Anyone with the verification key can verify the proof.","From this high-level overview, you can observe a few distinct design choices. First, ezkl utilizes a highly improved version of Halo2, which is a zero-knowledge proving system developed by Zcash, as its underlying cryptographic framework. This was selected for its \"public auditing\" through years of previous development and overall completeness. However, ezkl is not limited to the Halo2 proving system and is incorporating additional systems.","Further, as commonly done in ZK research, models' computational tasks are represented as circuits composed of logical gates, allowing for efficient ZKP generation. In order to convert computational tasks to circuits, we specifically support models in the ONNX format. ONNX is also used widely in the broader machine learning community.","Finally, ezkl supports a broad range of model architectures:","Tree-based Models: Decision trees and random forests are compiled by representing decision nodes as conditional statements in the circuit.","Transformers: These are handled by breaking down attention mechanisms and feed-forward layers into basic matrix operations that can be represented in the circuit.","Other Architectures: ezkl can theoretically compile any model representable in ONNX, including CNNs, RNNs, and custom architectures, by decomposing them into basic mathematical operations.","This flexibility allows ezkl to support a wide range of AI/ML applications, from traditional statistical models to cutting-edge deep learning architectures."]},{"l":"Developer Experience","p":["EZKL is designed with a core aim: to enable smooth developer experiences in working with zero-knowledge proofs. Developers should not require knowledge of cryptography or zero-knowledge proofs to use the library."]},{"l":"No Prerequisite Knowledge Required","p":["One of EZKL's key strengths is its accessibility. This is possible through the ezkl compiler. You don't need:","Cryptography expertise","Zero-knowledge proof theory understanding","Experience writing constraints","Knowledge of circuit design","Skills in orchestrating concurrent systems","Advanced DevOps knowledge","EZKL automates the complex underlying processes, allowing you to focus on your application logic."]},{"l":"Multiple Language Support","p":["EZKL supports different approaches to development, catering to different preferences and use cases:","Scripting/CLI. For those who prefer a command-line interface, EZKL offers a comprehensive CLI. This is ideal for quick operations and scripting.","Python. Python developers can leverage EZKL's Python bindings for integration into their existing workflows.","JavaScript. For web developers and Node.js enthusiasts, EZKL provides JavaScript bindings.","Rust. For those who need low-level control and maximum performance, EZKL can be used directly in Rust projects."]},{"l":"Abstraction of Complexity","p":["EZKL abstracts away the complexities typically associated with zero-knowledge proofs:","No Manual Circuit Design: Instead of hand-writing circuits, you can use standard machine learning models in ONNX format. EZKL automatically converts these into ZKP-compatible circuits.","Automated Constraint Generation: EZKL handles the generation of constraints, eliminating the need for developers to manually define them.","Simplified Proof Generation: The process of generating proofs is streamlined into simple function calls or CLI commands, hiding the intricate cryptographic operations.","Job Orchestration: When using Lilith, the orchestration of concurrent proof generation is managed for you, eliminating the need to design and implement complex distributed systems.","Managed DevOps: With Lilith's cloud offering, much of the DevOps complexity is abstracted away. You don't need to set up and maintain high-performance hardware for proof generation."]},{"l":"Scaling Proof Generation","p":["ezkl is designed not only as a proof compiler but also as a comprehensive system for generating zero-knowledge proofs at scale. It addresses the varying time sensitivities and computational demands across different use cases, from real-time financial operations to concurrent model proving.","While ezkl is a highly performant system, it primarily operates locally on a user's machine. This local execution can be limiting for very large models or when rapid, concurrent verifications are needed. To address these scalability challenges, we've developed Lilith.","Lilith is a high-performance compute cluster dedicated to generating EZKL proofs on top-of-the-line hardware. It serves as a remote orchestrator, allowing users to offload the computational burden of proof generation. Key benefits of using Lilith include:","Enhanced Computational Power: Enables processing of larger, more complex models.","Reduced Latency: Decreases proof generation time through distributed computing.","Concurrent Processing: Supports simultaneous proof generations for high-throughput scenarios.","Seamless Integration: Mirrors the ezkl CLI for easy scaling.","Flexible Interaction: Offers both CLI and REST API for varied integration needs.","While ezkl continues to be optimized for local use, Lilith extends its capabilities to cloud-scale operations. This dual approach ensures that EZKL can meet a wide range of performance and scalability requirements, from individual developers to enterprise-level applications.","For more details on how to use the EZKL system, we invite you to explore the remaining documentation and check out the original repository, example Jupyter notebooks, and our website."]},{"l":"Contribute","p":["If you're interested in contributing and are unsure where to start, reach out to one of the maintainers on our Telegram group or our Discord.","More broadly:","Feel free to open up a discussion topic to ask questions.","See currently open issues for ideas on how to contribute.","For PRs we use the conventional commits naming convention."]}],[{"l":"Products","p":["EZKL is a system for verifiable AI and analytics. The system includes two core products: the ezkl library and lilith orchestrator."]},{"l":"EZKL","p":["The ezkl library is free and open to install and run locally, designed for individuals and teams who want to explore compatibility or developer experience. It can be used in Python, JavaScript, and Rust programs. Note however that past version X.X.X, ezkl is not open for commercial usage without proper licensing."]},{"l":"Lilith","p":["Lilith is an orchestration platform for generating proofs at scale. It addresses a common issue we've observed: running more ambitious models or graphs with EZKL often maxes out developers' desktops and laptops. To expand what can be built using EZKL for everyone, we decided to provide some of our compute power.","Behind Lilith is a high-performance compute cluster dedicated to generating EZKL proofs on top-of-the-line hardware. The Lilith CLI serves as an orchestrator for triggering, scheduling, optimizing, and monitoring jobs. The key affordances of the platform include:","Enhanced Computational Power: Enables processing of larger, more complex models.","Reduced Latency: Decreases proof generation time through distributed computing.","Concurrent Processing: Supports simultaneous proof generations for high-throughput scenarios.","Seamless Integration: Mirrors the ezkl CLI for easy scaling.","Flexible Interaction: Offers both CLI and REST API for varied integration needs."]},{"l":"CLI Tool","p":["We've built Lilith to mirror the experience of using EZKL locally as closely as possible. For example, if you're familiar with the ezkl CLI, a typical pipeline like:","looks like this using Lilith:","Each job returns a job-id which can then be queried using:","For more complex behavior, such as callbacks, you can use:","This will send the proof as a JSON-encoded object to CALLBACK_URL upon job completion, allowing you to trigger jobs and get the result upon completion without needing to poll.","Effectively, EZKL is for local usage and Lilith is for remote usage. For the remaining documentation, we will demonstrate equivalent commands for EZKL CLI and Lilith CLI, as well as for Python and JavaScript environments."]},{"l":"REST API","p":["For more complex scripting, Lilith exposes a REST API. This allows you to programmatically trigger jobs, chain new jobs together, and add new data for the worker to operate upon, all in a single call.","For instance, to chain a gen-witness call and prove call together on new data:"]},{"l":"Usage Tiers","p":["Public Cluster","Free to use with certain caps on daily usage and overall proof storage. Intended for individuals, researchers, and teams who want to build simple applications or test EZKL's performance.","Enterprise Cluster","For access without daily usage and proof storage limitations. Useful for commercial applications and large-scale systems incorporating EZKL. Please reach out to the EZKL team if you are interested in enterprise access.","Private Deployment","A private deployment of the Lilith system, relevant for teams building application components with EZKL or miners/validators generating EZKL proofs. Please reach out to the EZKL team if you are interested in private deployment."]}],[{"l":"Getting Started","p":["Let's briefly preview the steps to generate and verify a model:","Model Preparation: prepare model and exports it as an ONNX file.","Settings Generation: run ezkl.gen_settings() to generate initial settings for the proof. Can optionally use ezkl.calibrate_settings() to optimize these settings.","Model Compilation: compile model using ezkl.compile_model(), which prepares it for the setup phase.","Setup: run ezkl.setup(), which defines the rules for the proof and verification. This step produces a proving key, a verification key, and circuit settings.","Witness Generation: generate the witness data (input-output pair) using ezkl.gen_witness().","Proof Generation: create the cryptographic proof using ezkl.prove(), which takes the witness data, compiled model, proving key, and other necessary components.","[OPTIONAL] Verifier Creation: If the proof needs to be verified on-chain, the user can create an EVM verifier contract using ezkl.create_evm_verifier().","[OPTIONAL] Deployment: For on-chain verification, the user deploys the verifier contract using ezkl.deploy_evm().","Verification: The proof can be verified using one of three methods - on-chain using ezkl.verify_evm() with the deployed contract, off-chain via CLI using the ezkl verify command, or off-chain in Python using ezkl.verify()","Each of these steps and associated vocabulary are covered in detail in the following sections. Continue to the next section for installation."]}],[{"l":"Installation","p":["Install the binary with the following bash script.","Alternatively, build from source:","For detailed options, use ezkl --help or ezkl command --help.","Install EZKL using pip:","You may also need to install additional dependencies:","onnx for exporting models","PyTorch or TensorFlow for creating models","To use EZKL in your Python code:","Install EZKL using npm:","To use EZKL in your JavaScript code:","Install archon with the following script","If your system settings block the installed binary you will need to allow your system to run the binary.","Set the server environment variable:","Test the connection:"]},{"l":"Additional Notes","p":["While there is some support for Windows with the original ezkl repository, unfortunately Lilith does not work on Windows systems.","EZKL uses your system's solc Solidity compiler. You may need to adjust it using svm-rs or solc-select.","For rendering model circuits with EZKL, compile with the render feature and install required libraries (e.g., libexpat1-dev and libfreetype6-dev on Debian systems).","For EZKL Rust documentation, use cargo doc --open."]}],[{"l":"Setup","p":["The lifecycle of an EZKL proof consists of three core components: Setup, Prove, and Verify. This page focuses on the Setup phase, which defines the rules for proof generation and verification. Recall that:","Setup: Defines proof parameters and generates keys (performed by developers)","Prove: Generates a proof based on the setup (performed by users)","Verify: Checks the validity of a proof (performed by verifiers)"]},{"l":"Process","p":["The setup process involves the following steps:","Generate settings: Creates a configuration file with default parameters for the circuit.","Calibrate settings (optional): Fine-tunes the circuit parameters to optimize for either accuracy or resource usage.","Compile the model: Converts the ONNX model into a format optimized for zero-knowledge proofs.","Run setup: Generates the cryptographic keys needed for proving and verifying."]},{"l":"Parameters","p":["To perform the setup, you'll need to provide and/or create the following:"]},{"l":"ONNX File","p":["For PyTorch:","For TensorFlow:"]},{"l":"Configuration Options","p":["These are defined in the settings.json file, which is generated and optionally calibrated during the setup process."]},{"l":"Instructions","p":["Generate settings:","This creates a settings.json file with default parameters based on your ONNX model.","Calibrate settings (optional):","This optimizes the settings for resource usage. You can also use --target accuracy to optimize for accuracy, and --target resources to optimize for resources.","Compile model:","This converts your ONNX model into an optimized format for zero-knowledge proofs, creating the network.ezkl file.","Run setup:","This generates the cryptographic keys needed for proving and verifying.","This optimizes the settings for resource usage. You can also use target=accuracy to optimize for accuracy.","This optimizes the settings for resource usage. You can also use { target: accuracy } to optimize for accuracy.","Upload your files,"]},{"l":"Outputs","p":["The setup process will generate the following:","network.onnx: model in ONNX format.","settings.json: generated file which is optionally calibrated during the setup process.","network.ezkl: compiled circuit created from your ONNX model in step 3.","kzg.srs: Structured Reference String (SRS), which you can download using ezkl get-srs.","vk.key and pk.key: verification and proving keys generated during the setup process."]}],[{"l":"Prove","p":["The lifecycle of an EZKL proof consists of three core components: Setup, Prove, and Verify. This page focuses on the Prove phase, which defines the rules for proof generation and verification. Recall that:","Setup: Defines proof parameters and generates keys (performed by developers)","Prove: Generates a proof based on the setup (performed by users)","Verify: Checks the validity of a proof (performed by verifiers)"]},{"l":"Process","p":["The setup process involves the following steps:","Generate witness: Creates a witness file from the input data and the compiled model.","A witness in this context is a comprehensive record of all the intermediate values and computations performed when running the input through the machine learning model. It includes:","The input data","All intermediate layer outputs","The final output of the model","Any additional data required for the proof (e.g., random numbers used in the computation)","The witness serves as a \"trace\" of the computation, allowing the prover to demonstrate knowledge of all the steps involved in running the input through the model without revealing the specific values.","Generate proof: Uses the witness, proving key, and other artifacts to create a zero-knowledge proof."]},{"l":"Parameters","p":["To generate a proof, you'll need the following:","network.ezkl: compiled circuit file","input.json: input data file","pk.key: proving key","settings.json: settings file","kzg.srs: structured Reference String (SRS) file","Note that if you performed the Setup phase as instructed on the previous page, the CLI automatically pull from the correct paths and you should not have to specify the above parameters."]},{"l":"Instructions","p":["Generate witness:","This creates a witness file from your input data and compiled model.","Generate proof:","This generates a zero-knowledge proof using the witness and other artifacts."]},{"l":"Outputs","p":["The proof generation process will produce the following:","witness.json: intermediate values computed during the execution of the circuit","proof.json: zero-knowledge proof artifact"]}],[{"l":"Verify","p":["The lifecycle of an EZKL proof consists of three core components: Setup, Prove, and Verify. This page focuses on the Verify phase, which checks the validity of a proof. Recall that:","Setup: Defines proof parameters and generates keys (performed by developers)","Prove: Generates a proof based on the setup (performed by users)","Verify: Checks the validity of a proof (performed by verifiers)"]},{"l":"Process","p":["The verification process involves a single step, verify proof. This can simply be done in-program or in-browser as demonstrated below."]},{"l":"Parameters","p":["To verify a proof, you'll need the following:","proof.json: proof artifact","vk.key: verification key","settings.json: settings file","kzg.srs: structured Reference String (SRS) file","Note that if you performed the Prove phase as instructed on the previous page, the CLI automatically pull from the correct paths and you should not have to specify the above parameters."]},{"l":"Instructions for In-Program Verification","p":["This verifies the zero-knowledge proof using the provided artifacts."]},{"l":"Outputs","p":["The verification result is a boolean value:","true: The proof is valid. The prover has demonstrated knowledge of inputs that satisfy the circuit constraints.","false: The proof is invalid. This could be due to an incorrect proof or tampered input data."]}],[{"l":"Verify Onchain","p":["The lifecycle of an EZKL proof consists of three core components: Setup, Prove, and Verify. This page focuses on the Verify phase, which checks the validity of a proof. Recall that:","Setup: Defines proof parameters and generates keys (performed by developers)","Prove: Generates a proof based on the setup (performed by users)","Verify: Checks the validity of a proof (performed by verifiers)"]},{"l":"Process","p":["The offchain verification process involves a single step, verify proof. This can simply be done in-program or in-browser using Lilith.","However, there is the option of verification on-chain as well (for smart contract applications). Verifying proofs on-chain offers several advantages:","Smart Contract Integration: On-chain verification allows other smart contracts to react to valid proofs, enabling complex decentralized applications.","Gas Efficiency: While initial deployment of the verifier contract may be costly, subsequent verifications are typically much cheaper than performing the full computation on-chain.","Reusability: Once deployed, the verifier contract can be used multiple times, amortizing the initial deployment cost and making it persistently accessible to other calling contracts.","Privacy: On-chain verification maintains the privacy guarantees of the zero-knowledge proof, allowing for confidential data processing in public blockchains","If you are integrating with smart contracts, consider the following:","Verifier Contract: The EZKL-generated verifier contract contains the logic to verify proofs. This contract should be deployed once and can be used for multiple verifications.","Proof Submission: Design your smart contracts to accept proof data as input. This typically includes the proof itself and any public inputs.","Result Handling: The verifier contract's verify function returns a boolean. Your contract should check this result and act accordingly.","Gas Optimization: Consider implementing batched proof verification if your use case involves verifying multiple proofs in a single transaction.","Upgradability: If you anticipate changes to your ML model or proof system, consider implementing upgradeable smart contracts."]},{"l":"Parameters","p":["To verify a proof, you'll need the following:","proof.json: proof artifact","vk.key: verification key","settings.json: settings file","kzg.srs: structured Reference String (SRS) file","Note that if you performed the Prove phase as instructed on the previous page, the CLI automatically pull from the correct paths and you should not have to specify the above parameters."]},{"l":"Instructions for On-Chain Verification","p":["Generate Solidity verifier contract:","Deploy the generated contract to an Ethereum network using your preferred method (e.g., Hardhat, Truffle, or Remix).","Interact with the deployed contract:","Call the processProof function with the EZKL-generated proof and public inputs.","The process is similar to Ethereum, so long as the chain has the XXX precompiles. Deploy the generated Solidity contract to your chosen EVM-compatible chain (e.g., Polygon, Binance Smart Chain, Avalanche) and interact with it using the chain's specific tools and SDKs.","Example for Polygon using Web3.js:","Support for Solana verification is planned for future releases. Stay tuned for updates.","EZKL is actively working on supporting more blockchain platforms. Check the documentation or reach out to the community for the latest updates on supported chains."]},{"l":"Outputs","p":["The verification result is a boolean value:","true: The proof is valid. The prover has demonstrated knowledge of inputs that satisfy the circuit constraints.","false: The proof is invalid. This could be due to an incorrect proof or tampered input data.","If you are attempting to read these results from a smart contract, you will need to decode the results. In Solidity, you might handle the result like this:"]}],[{"l":"Advanced"}],[{"l":"Python Bindings","p":["PyO3 bindings were created for the Rust binary. Please note that due to various interactions with Python, the Python bindings will be less performant than using the Rust binary.","Python bindings are found on https://pythonbindings.ezkl.xyz"]}],[{"l":"Troubleshooting","p":["If you need direct technical support, join our Discord to post your question in the #ezkl-support-forum and tag @devhelp to get a response from the team."]},{"i":"what-programming-languages-and-frameworks-does-ezkl-support","l":"What programming languages and frameworks does ezkl support?","p":["ezkl is a command line tool, and a library that can be used from Rust or Python. You may want to use Python to create a neural network and export it. Though ezkl is built with Rust, you do not need to use Rust except possibly for installation."]},{"i":"do-i-need-to-know-rust-before-getting-started-with-ezkl","l":"Do I need to know Rust before getting started with ezkl?","p":["No, Rust is not a requirement to use the library. As long as you have the ONNX file and proper input & output format of the model, you can use ezkl."]},{"l":"Technical"},{"i":"why-is-the-gen-srs-step-slow","l":"Why is the gen-srs step slow?","p":["Generating a structured reference string takes a considerable amount of time and memory. Make sure your machine has enough memory available and wait for the process to finish. Alternatively, download a pre-generated srs using get-srs. This is both safer and faster."]},{"i":"can-i-use-ezkl-with-other-machine-learning-frameworks-like-tensorflow-pytorch-or-scikit-learn","l":"Can I use ezkl with other machine learning frameworks like TensorFlow, PyTorch, or Scikit-learn?","p":["All ezkl requires is an onnx file and a JSON configuration of mock inputs and outputs of the neural network. At this time, it works best with PyTorch."]},{"i":"how-fast-is-ezkl","l":"How fast is ezkl?","p":["We believe that ezkl is the fastest zkml package available, and we are working hard every day to make it faster. Feel free to run cargo bench on your machine to see what the benchmarks are for your hardware."]},{"i":"do-i-need-to-deploy-a-verifier-smart-contract-to-use-ezkl","l":"Do I need to deploy a verifier smart contract to use ezkl?","p":["No. We recently integrated a WASM verifier that you can use to verify proofs from your web application. You can also use the EVM verifier to verify proofs locally, or the command line ezkl verify command."]},{"l":"Errors"},{"i":"error-verifyerror","l":"Error: VerifyError","p":["A VerifyError is thrown when the Mock prover fails, often due to a mismatched shape problem in the model. Please verify that your input.json inputs and outputs match those of your .onnx file."]},{"i":"error-dimmismatch","l":"Error: DimMismatch","p":["A DimMismatch error is thrown when there is a mismatch in the lengths of the tensor operands during circuit construction."]},{"i":"error-lookupinstantiation","l":"Error: LookupInstantiation","p":["This error is thrown when there is an error during the creation of a lookup table."]},{"i":"error-tablealreadyassigned","l":"Error: TableAlreadyAssigned","p":["A TableAlreadyAssigned Error is thrown when ezkl attempts to initialize a lookup table that has already been initialized."]},{"i":"error-unsupportedop","l":"Error: UnsupportedOp","p":["An UnsupportedOp Error is thrown when there is an operation in the ONNX file that ezkl cannot yet handle. Please look at the supported operations under src/circuit/ops to get an idea of what operations ezkl can handle."]},{"i":"error-pyvalueerror","l":"Error: PyValueError","p":["This is a pyo3 error that occurs when a data type fails to be extracted from Python to Rust. Please make sure you are passing the correct data types when utilizing the python bindings."]},{"i":"error-invalidlookupinputs","l":"Error: InvalidLookupInputs","p":["InvalidLookupInputs is thrown when the wrong inputs were passed to a lookup node."]},{"i":"error-invaliddims","l":"Error: InvalidDims","p":["InvalidDims is thrown when there is a shape mismatch in circuit construction. Invalid dimensions were used for a node with the given index and description."]},{"i":"error-wrongmethod","l":"Error: WrongMethod","p":["This error means that the wrong method was called to configure a node with the given index and description."]},{"i":"error-missingnode","l":"Error: MissingNode","p":["MissingNode is thrown when a requested node is missing in the graph with the given index."]},{"i":"error-opmismatch","l":"Error: OpMismatch","p":["OpMismatch is thrown when an unsupported method was called on a node with the given index and description."]},{"i":"error-unsupportedop-1","l":"Error: UnsupportedOp","p":["UnsupportedOp is thrown when there is an operation in the onnx graph that isn't supported by ezkl."]},{"i":"error-missingparams","l":"Error: MissingParams","p":["MissingParams is thrown when a node has missing parameters; please check the parameters in your model's operations."]},{"i":"error-misformedparams","l":"Error: MisformedParams","p":["MisformedParams is thrown when a node has misformed parameters; the error can stem from erroneous padding height and width dimensions, wrong kernel / data format, dilations that are not uint type, and more."]},{"i":"error-visibility","l":"Error: Visibility","p":["This error is typically thrown when no public variables are passed to the circuit configuration function."]},{"i":"error-nonconstantdiv","l":"Error: NonConstantDiv","p":["ezkl only supports divisions by constants."]},{"i":"error-nonconstantpower","l":"Error: NonConstantPower","p":["ezkl only supports constant exponents."]},{"i":"error-rescalingerror","l":"Error: RescalingError","p":["This error is thrown when attempting to rescale inputs for an operation."]},{"i":"error-modelload","l":"Error: ModelLoad","p":["This error is thrown when a model fails to load. Please check your onnx file for missing connections / unsupported layers. We suggest using Netron to view onnx files."]}],[{"l":"Security","p":["Zero knowledge machine learning, particularly in blockchain applications, is still a nascent field and should be used with caution. Because there have not yet been many production-ready projects, the potential attack vectors include both the usual and the mostly theoretical or unknown. ezkl has not been audited and we make no guarantees on its security.","Moreover, zkml is just one component of an overall cryptosystem, and that system as a whole has to be carefully thought out. Neural networks are not by themselves adequate hash functions; the whole point is that they are susceptible to differentiation!","Here are a few more things to worry about."]},{"i":"aiml-security","l":"AI/ML Security","p":["There are several types of adversarial attacks on neural networks. Gaussian Noise Injection, Data poisoning, Membership Inference Attacks(MIAs), and more are attack vectors that adversaries can use to corrupt your outputs. MIAs and others like it are especially hazardous when the aim of using zkml is to keep the model and its training data private.","Adversarial Training involves training your model with adversarial data so that edge cases are expected and accounted for. CleverHans is a useful tool for discovering potential vulnerabilities in your model. For best security results, have an idea of the overall threat model of your neural net and its potential inputs."]},{"l":"ZK Security","p":["The goal of zero knowledge proof systems is to construct complete, sound proofs. Completeness is the highly probable assurance that any valid proof will verify. Soundness is the quality of the verifier (or parties representing the verifier) knowing that if a proof passes, it is more than likely a true statement. In some cases, such as those in underconstrained circuits, bad proofs can be generated that fool the verifier into passing a false statement. In this case, the vulnerability is not in the machine learning model itself, but in the SNARK constructed by ezkl.","ezkl is a compiler, so eventually should be less susceptible to such issues than a hand-written circuit, but it is still under active development.","Please reach out directly to let us know of any soundness issues you encounter.","Thank you for using ezkl. Please contact us if you have any comments on this documentation."]}],[{"l":"Resources"},{"l":"Resources","p":["Dante and Jason - Zero-Knowledge Machine Learning with EZKL in Autonomous Worlds","Jason Morton - What Is Unlocked by Practical Zero-Knowledge Proofs? | EDCON 2023 Montenegro","Zuzalu ZKML 101 and panel.","Empower - coming soon","ETH Denver talks - coming soon","Jason Morton - Zero-Knowledge Machine Learning 6 Jan 2023 | ZK SYMPOSIUM","Jason Morton - Zero-Knowledge Machine Learning 16 Nov 2022 | ZkProof Tel Aviv","Jason Morton - Zero-Knowledge Machine Learning 15 Sep 2022 | DEVCON Bogota","Jason Morton - Zero-Knowledge Machine Learning | Stanford Science of Blockchain Conference 2 Sept 2022"]},{"l":"Blog posts","p":["Constraint efficiency","Snarking a GPT"]},{"l":"EZKL in the press and blogs","p":["Spectral Finance: The State of Zero-Knowledge Machine Learning (zkML), 6 June 2023","Fortune: A brief history of zero-knowledge proofs, the buzzy mathematical technique that’s taken crypto by storm, 5 June 2023","1kx: zkML: Evolving the Intelligence of Smart Contracts Through Zero-Knowledge Cryptography, 23 May 2023","Fortune, 4 May 2023","a16z: Checks and balances: Machine learning and zero-knowledge proofs, 5 Apr 2023","SevenX Ventures: Balancing the Power of AI/ML: The Role of ZK and Blockchain","Coincu: ZKML: Breakthrough Technology With Growth Potential In Security Application","Worldcoin: An introduction to zero-knowledge machine learning (ZKML) 22 Feb 2023"]}]]